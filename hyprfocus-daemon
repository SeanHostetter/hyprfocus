#!/usr/bin/env bash
# hyprfocus-daemon - Capture workspace thumbnails on events
# Listens for workspace changes and captures thumbnails automatically

# === DIRECTORIES ===
CACHE_DIR="${XDG_CACHE_HOME:-$HOME/.cache}/hyprfocus"
CONFIG_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/hyprfocus"
CONFIG_FILE="$CONFIG_DIR/config"
LOG_FILE="$CACHE_DIR/daemon.log"

# === DEFAULT CONFIG ===
CAPTURE_ENABLED=true
THUMB_SCALE=0.15
CAPTURE_DELAY=0.3
PERIODIC_INTERVAL=7
CLEAR_CACHE_ON_START=true

# === LOAD USER CONFIG ===
mkdir -p "$CACHE_DIR" "$CONFIG_DIR"
[[ -f "$CONFIG_FILE" ]] && source "$CONFIG_FILE"

# === LOGGING ===
log() { 
    local msg="[$(date '+%H:%M:%S')] $*"
    echo "$msg"
    echo "$msg" >> "$LOG_FILE"
}

# === MONITOR/WORKSPACE FUNCTIONS ===
get_focused_monitor() {
    hyprctl monitors -j | jq -r '.[] | select(.focused) | .name'
}

get_active_workspace() {
    hyprctl activeworkspace -j | jq -r '.id'
}

# === CAPTURE FUNCTIONS ===
capture_workspace_on_monitor() {
    local ws_id="$1"
    local monitor="$2"
    
    if grim -o "$monitor" -s "$THUMB_SCALE" "$CACHE_DIR/workspace-$ws_id.png" 2>/dev/null; then
        log "Captured workspace $ws_id on $monitor"
    fi
}

capture() {
    [[ "$CAPTURE_ENABLED" != "true" ]] && return 0
    
    local ws_id monitor
    ws_id=$(get_active_workspace)
    monitor=$(get_focused_monitor)
    
    if [[ -z "$ws_id" || -z "$monitor" ]]; then
        log "ERROR: Could not get workspace ($ws_id) or monitor ($monitor)"
        return 1
    fi
    
    capture_workspace_on_monitor "$ws_id" "$monitor"
}

capture_all_monitors() {
    [[ "$CAPTURE_ENABLED" != "true" ]] && return 0
    
    hyprctl monitors -j | jq -r '.[] | "\(.name) \(.activeWorkspace.id)"' | while read -r monitor ws_id; do
        if [[ -n "$monitor" && -n "$ws_id" ]]; then
            capture_workspace_on_monitor "$ws_id" "$monitor"
        fi
    done
}

capture_delayed() {
    sleep "$CAPTURE_DELAY"
    capture
}

# === PERIODIC CAPTURE ===
periodic_capture() {
    [[ "$PERIODIC_INTERVAL" == "0" ]] && {
        log "Periodic capture disabled (interval=0)"
        return 0
    }
    
    log "Periodic capture started (every ${PERIODIC_INTERVAL}s, all monitors)"
    while true; do
        sleep "$PERIODIC_INTERVAL"
        capture_all_monitors
    done
}

# === CACHE MANAGEMENT ===
clear_cache() {
    log "Clearing old thumbnails..."
    rm -f "$CACHE_DIR"/workspace-*.png
}

# === MAIN EVENT LOOP ===
listen_events() {
    # Truncate old log
    echo "" > "$LOG_FILE"
    log "Daemon started (PID: $$)"
    log "Config: capture=$CAPTURE_ENABLED scale=$THUMB_SCALE interval=$PERIODIC_INTERVAL"
    
    # Clear cache on start if enabled
    [[ "$CLEAR_CACHE_ON_START" == "true" ]] && clear_cache
    
    # Start periodic capture in background (if enabled)
    if [[ "$PERIODIC_INTERVAL" != "0" ]]; then
        periodic_capture &
        local periodic_pid=$!
        log "Periodic capture PID: $periodic_pid"
        trap "log 'Stopping...'; kill $periodic_pid 2>/dev/null; exit 0" EXIT INT TERM
    fi
    
    # Capture current workspace immediately
    sleep 0.5
    capture
    
    # Listen for events
    local socket="$XDG_RUNTIME_DIR/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock"
    
    if [[ ! -S "$socket" ]]; then
        log "ERROR: Hyprland socket not found: $socket"
        exit 1
    fi
    
    log "Listening on socket"
    
    socat -U - "UNIX-CONNECT:$socket" 2>/dev/null | while IFS= read -r line; do
        case "$line" in
            workspace\>\>*|workspacev2\>\>*)
                log "Event: $line"
                capture_delayed &
                ;;
            createworkspace\>\>*|createworkspacev2\>\>*)
                log "Event: $line"
                capture_delayed &
                ;;
        esac
    done
    
    log "Socket connection ended"
}

# === MAIN ===
main() {
    case "${1:-}" in
        --start)
            # Properly daemonize
            for cmd in hyprctl jq grim socat setsid; do
                command -v "$cmd" &>/dev/null || { echo "Missing: $cmd"; exit 1; }
            done
            [[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]] || { echo "Hyprland not running"; exit 1; }
            
            echo "Starting daemon..."
            setsid "$0" </dev/null &>/dev/null &
            sleep 1
            if pgrep -f "hyprfocus-daemon" >/dev/null 2>&1; then
                echo "Daemon started (PID: $(pgrep -f 'hyprfocus-daemon' | head -1))"
            else
                echo "Failed to start daemon"
                exit 1
            fi
            ;;
        --stop)
            pkill -f "hyprfocus-daemon" 2>/dev/null || true
            echo "Stopped"
            ;;
        --restart)
            "$0" --stop
            sleep 1
            "$0" --start
            ;;
        --status)
            if pgrep -f "hyprfocus-daemon" >/dev/null 2>&1; then
                echo "Running (PID: $(pgrep -f 'hyprfocus-daemon' | head -1))"
            else
                echo "Not running"
            fi
            ;;
        --log)
            tail -f "$LOG_FILE"
            ;;
        --clear)
            clear_cache
            echo "Cache cleared"
            ;;
        --help|-h)
            echo "hyprfocus-daemon - Background thumbnail capture"
            echo ""
            echo "Usage: hyprfocus-daemon [OPTION]"
            echo ""
            echo "Options:"
            echo "  --start    Start daemon (detached)"
            echo "  --stop     Stop daemon"
            echo "  --restart  Restart daemon"
            echo "  --status   Check if running"
            echo "  --log      Watch daemon log"
            echo "  --clear    Clear thumbnail cache"
            echo "  --help     Show this help"
            echo ""
            echo "Config: $CONFIG_FILE"
            ;;
        *)
            # Direct run (for exec-once)
            for cmd in hyprctl jq grim socat; do
                command -v "$cmd" &>/dev/null || { echo "Missing: $cmd"; exit 1; }
            done
            [[ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ]] || { echo "Hyprland not running"; exit 1; }
            
            listen_events
            ;;
    esac
}

main "$@"
